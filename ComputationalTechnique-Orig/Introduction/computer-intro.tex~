Modern statistics is done on the computer.  There was a time, 60 years
ago and before, when computation could only be done by hand or using
balky mechanical calculators.  The methods of applied statistics
developed during this time reflected what could be done using such
calculators, not necessarily what was best for illuminating the
system under study.  These methods took on a life of their own ---
they became the operational definition of statistics.  They continue
to be taught today, using electronic calculators or personal
computers or even just using paper and pencil.  For the old
statistical methods, computers are merely a labor saving device.

But not for modern statistics.  The statistical methods at the core of
this book cannot be applied in a authentic and realistic way without
powerful computers.  Thirty years ago, many of the methods 
could not be done at all
unless you had access to the resources of a government agency or a
large university.  But with the revolutionary advances in computer
hardware and numerical algorithms over the last half-century, modern
statistical calculations can be performed on an ordinary home computer
or laptop. (Even a cell phone has phenomenal computational power,
often besting the mainframes of thirty years ago.)
Hardware and software today pose no limitation; they are readily
available.  

Each chapter of this book includes a section on computational
technique.  Many readers will be completely new to the use of
computers for scientific and statistial work, so the first chapters
cover the foundations, techniques that are useful for many different
aspects of computation.  Working through the early chapters is essential
for developing the skills that will be used later in actual
statistical work.  It will take a few hours, but this investment will
pay off handsomely.

Chances are, you use a computer almost every day: email,
word-processing, managing your music or your photograph collection, 
perhaps even using a spreadsheet program for accounting. The software
you use for such activities makes it easy to get started.  Possibly
you have never even looked at an instruction manual or used the ``help''
features on your computer. 

When you use a word processor or email, the bulk of what you enter
into the computer --- the content of your documents and email --- is
without meaning to the computer.  This is not at all to say that it is
meaningless.  Your documents and letters are intended for human
readers; most of the work you do is directed so that the recipients
can understand them.  But the computer doesn't need to understand what
you write in order to format it, print it, or transmit it over the
Internet.  Indeed, the computer would be equally effective at handling
random text generated by typing monkeys.

When doing scientific and statistical computing, things are different.
What you enter into the computer is instructions to the computer to
perform calculations and re-arrangements of data.  Those instructions
have to be comprehensible to the computer.  If they make no sense or
if they are inconsistent or ill formed, the computer won't be able to
carry out your instructions.  Worse, if the instructions make sense in
some formal way but don't convey your actual intentions, the computer
will perform some operation but the result will mislead you.

The difficulty with using software for mathematics and statistics is
in making sure that your instructions make sense and do what you want
them to do.  This difficulty is not a matter of bad software design;
it's intrinsic to the problem of communicating your intentions to the
computer.  The same difficulty would arise in word processing if
the computer had to make sense of your writing, rejecting it
when a claim is unconvincing or when a sentence is  ambiguous.

Much of the design of packages for scientific and statistical work is
oriented around the difficulty of communicating intentions.  A popular
approach is based on the computer mouse: the program provides a list of
possible operations --- like the keys on a calculator --- and lets the
user choose which operation to apply to some selected data.  This
style of user interface is employed, for example, in spreadsheet software, letting users
add up columns of numbers, make graphs, etc.  The reason this style
is popular is that it can make things extremely easy ... so long as
the operation that you want has been included in the software.  But
things get very hard if you need to construct your own operation.

Another style of scientific computation --- the one used in this
book --- is based on language.  Rather than selecting an option with a
mouse, you construct a \newword{command} that conveys both the
operation that you want and the data to which you want to apply that
operation.  There are dramatic advantages to this language-based
style of computation:

\begin{itemize}
\item It lets you {\bf connect} computations on one another, so that the
  output of one operation can become the input to another.
\item It lets you {\bf repeat} the operation on new or modified data,
  allowing you to automate tedious tasks and, importantly, to verify
  the correctness of your computations on data where you already know
  the answer.
\item It lets you {\bf accumulate} the results of previous operations,
  treating those results as new data.
\item It lets you {\bf document} concisely what was done so that you can
  demonstrate that what you said you did is what you actually did and
  so that you or others can repeat the analysis 
  later if necessary to confirm your results.
\item It lets you {\bf modify} the computation in a controlled way
  to correct it or to vary some aspect of it while holding other
  aspects exactly the same as in the original.
\end{itemize}

In order to use the language-based approach, you will need to learn a
few principles of the language itself: some vocabulary, some syntax,
some grammar.  This is much, much easier for the computer language
than for a natural language like English or Chinese; it will take you
only a couple of hours before you are fluent enough to do useful
computations.  In addition to letting you perform scientific
computations in ways that use the computer and your own time and
effort effectively, the principles that you will learn are broadly
applicable to many computer systems and can provide significant
insight even to how to use mouse-based interfaces,

\sectionone{The R Environment}

The software package that you will be using is called R.  The R
package provides an environment for doing statistical and scientific
computation at a professional level. It was designed for statistics
work, but suitable for other forms of scientific calculations and the
creation of high-quality scientific graphics.\cite{R-software}

One nice feature of R is that it is available for free and works on the
major types of computers, e.g., Windows, Macintosh, and
Unix/Linux. You can get information about how to install R on your
computer at \url{www.r-project.org}.

Even if the R package were not free, it would compare favorably with
other modern packages for scientific and mathematical computing.  One
of its strengths is that the programming language that the package
supports --- called the R language --- is quite modern.  The language
incorporates many features that make it relatively easy to write new
operations and add new features to the package.  As a result, there is
a large community of software authors who contribute to R and a huge
variety of software available for specialized purposes.  The modern
features of the language allow users to sidestep many of the pitfalls
that have traditionally made it difficult for people to use computer
languages. 

Because computing is so important to contemporary science and
mathematics, there are many other packages available.  Each has its
own advantages and its own devoted group of users.  Three of the
leading packages are MATLAB, Mathematica, and Maple.  MATLAB is
particularly strong for large-scale numerical computing relating to linear
algebra (which is at the heart of scientific and statistical
computing).  Mathematica and Maple offer powerful facilities for
algebraic and symbolic manipulation in addition to strong numerical
capabilities.  All three packages have extensive graphical
capabilities. 

In addition to R, 
there are several major software packages widely used in statistics.
Among the leaders are SPSS, SAS, and STATA.  Each of these packages
has its strong points.  These are typically specialized computations
that are important in one field or another.  SAS is well regarded for
handling huge data sets.  It is, however, relatively difficult to add
new features to these packages because the languages they support are
old-fashioned.  To many users, however, this is unimportant because
the operations they need are already included in the package.

Another package that's often used in statistical work is the
spreadsheet program Excel. This package has its own advantages. It's
effective for entering data and has nice facilities for formatting
tables.  It's widely taught in high schools. The visual layout of the
data seems to be intuitive to many people.  Many businesses use Excel
and it's widely taught in high schools.  Unfortunately, it's very
difficult to use for statistical analyses of any sophistication.
Indeed, even some very things such as making a histogram is difficult
to do in Excel and the results are usually unsatisfactory from a
graphical point of view.
Worse, Excel is very hard to use reliably --- there are lots of
opportunities to make mistakes that will go undetected and it
encourages bad programming practices that make software unreliable.

\sectionone{Invoking an Operation}

People often think of computers as {\em doing} things: sending email,
playing music, storing files.  Your job in using a computer is to tell
the computer {\em what} to do.  There are many different words used 
to refer to the ``what'': a procedure, a task, a function, a routine,
and so on.  I'll use the word \newword{computation}.  Admittedly, this
is a bit circular, but it is easy to remember: computers perform computations.

A simple, but powerful idea is that complex computations are
built up from simpler computations.  To help distinguish between the
computation as a whole and the simpler parts, it helpful to introduce
a new word: an \newword{operator} performs a computation. 

It's helpful to think of the computation carried out by an operator 
as involving four parts:
\begin{enumerate}
\item The name of the operator
\item The input arguments
\item The output value
\item Side effects
\end{enumerate}
A typical operation takes one or more \newword{input arguments} and uses the
information in these to produce an \newword{output value}.  Along the way, the
computer might take some action: display a graph,
store a file, make a sound, etc.  These actions are called
\newword{side effects}.  

To tell the computer to perform an computation --- I'll call this
\newword{invoking a operation} or giving a \newword{command} --- 
you need to provide the
name and the input arguments in a specific format. The computer then
returns the output value.  For example, the command \code{sqrt(25)}
invokes the square root operator (named \code{sqrt}) on the argument
25.  The output from the computation will, of course, be 5.

The syntax for invoking an operation consists of the operator's name,
followed by round parentheses.  The input arguments go inside the
parentheses.

The software program that you use to invoke operators
is called an \newword{interpreter}.
You enter your commands as a dialog between you and the
interpreter.  To start, the interpreter prints a prompt, after which you
type your command:


\noindent\begin{tikzpicture}
\node (prompt) at (0,0) [ellipse,fill=red!20] {\verb+>+};
\node (promptlabel) at (-3,0) {\small\sc Prompt};
\draw [->] (promptlabel.east) -- (prompt.west);
\node (statement) at (1.5,0) [rectangle,fill=black!20] {\verb+sqrt(25)+};
\node (commandlabel) at (4,0) {\small\sc Command};
\draw [->] (commandlabel.west) -- (statement.east);
\end{tikzpicture}

When you press ``Enter,'' the interpreter reads your command and performs
the computation.  For commands such as this one, the interpreter
will print the output value from the computation:

\noindent\begin{tikzpicture}
\node (prompt) at (0,0) [ellipse,fill=red!20] {\verb+>+};
%\node (promptlabel) at (-3,0) {\small\sc Prompt};
%\draw [->] (promptlabel.east) -- (prompt.west);
\node (statement) at (1.5,0) [rectangle,fill=black!20] {\verb+sqrt(25)+};
%\node (commandlabel) at (4,0) {\small\sc Command};
%\draw [->] (commandlabel.west) -- (statement.east);
\node (output)  at (1,-.75)  {\verb+[1]   5+};
\node (outputlabel) at (4,-.75) {\small\sc Output Value};
\node (outputmarker) at (-2.25, -.75) {\small \sc Output Marker};
\draw [->] (outputmarker.east) -- (output.west);
\draw [->] (outputlabel.west) -- (output.east);
\node (prompt2) at (0, -1.5) [ellipse,fill=red!20] {\verb+>+};
\node (nextlabel) at (-2.5,-1.5) {\small\sc Next Prompt};
\draw [->] (nextlabel.east) -- (prompt2.west);
\end{tikzpicture}

\noindent The dialog continues as the interpreter prints another prompt and
waits for your further command.

To save space, I'll usually show just the give-and-take from one round
of the dialog:
\begin{verbatim}
> sqrt(25)
[1] 5
\end{verbatim}

Often, operations involve more than one argument.  The various
arguments are separated by commas.  For example, here is an operation
named \code{seq}
that produces a sequence of numbers:
% to color text: \textcolor{red}{the text to be colored}
\begin{verbatim}
> seq(3,10)
 [1]  3  4  5  6  7  8  9 10
\end{verbatim}

The first argument tells where to start the sequence, the second tells
where to end it.

The order of the arguments is important.  Here is the sequence
produced when 10 is the first argument and 3 the second:
\begin{verbatim}
> seq(10,3)
[1] 10  9  8  7  6  5  4  3
\end{verbatim}

For some operators, particularly those that have many input arguments,
some of the arguments can be referred to by name rather than
position. This is particularly useful when the named argument has a
sensible default value.
For example, the \code{seq} operator can be instructed how big a
jump to take between successive items in the sequence.  This is
accomplished using an argument named \code{by}:
\begin{verbatim}
> seq(3,10,by=2)
[1] 3 5 7 9
\end{verbatim}


Depending on the circumstances, all four parts of a
operation need not be present.  For example, the \code{date}
operation returns the current time and date; there's no argument needed:
\begin{verbatim}
> date()
[1] "Wed Apr 16 06:18:06 2008"
\end{verbatim}
Note that even though there are no arguments, the parentheses are
still used.  Think of the pair of parentheses as meaning, ``Do this.''




\sectiontwo{Naming and Storing Values}

Often the value returned by an operation will be used later on.
Values can be stored for later use with 
the \newword{assignment operator}.  This has a different syntax that
reminds the user that a value is being stored.  Here's an example of a
simple assignment:
\begin{verbatim}
> x = 16
\end{verbatim}
This command has stored the value 16 under the name \code{x}.
The syntax is always the same: an equal sign (\code{=}) with a name
on the left and a value on the right.

Such stored values are called \newword{objects}.  Making an assignment
to an object \newword{defines} the object.  Once an object has been
defined, it can be \newword{referred to} and used in later computations.

Notice that an assignment operation does not return a value or display
a value.  Its sole purpose is to have the side effects of defining the
object and thereby storing a value under the object's name.

To refer to the value stored in the object, 
just use the object's name itself. For instance:
\begin{verbatim}
> x
[1] 16
\end{verbatim}
Do a computation on the value stored in an object is much the same:
\begin{verbatim}
> sqrt(x)
[1] 4
\end{verbatim}


You can create as many objects as you like and give them names that remind you 
of their purpose.  Some examples: \code{wilma}, \code{ages}, \code{temp},
\code{dog.houses}, \code{foo3}.  There are some rules:
\begin{itemize}
\item Use only letters and numbers and the two punctuation marks
  ``dot'' (\code{.}) and ``underscore'' (\verb+_+).
\item Do NOT use spaces anywhere in the name.
\item A number or underscore cannot be the first character in the name.
\item Capital letters are treated as distinct from lower-case letters.
  The objects named \code{wilma} and \code{Wilma} are
  different.   
\end{itemize}
For the sake of readability, keep object names short.  But if you really must have an object named something like 
\code{agesOfChildrenFromTheClinicalTrial}, feel free.

Objects can store all sorts of things, for example a sequence of numbers:
\begin{verbatim}
> x = seq(1,7)
\end{verbatim}
When you assign a new value to an existing object, as I just did to
\code{x}, the former value of
that object is erased from the computer memory. The former value of \code{x} was 16, but after the above assignment command it is 
\begin{verbatim}
> x
 [1]  1  2  3  4  5  6  7  
\end{verbatim}

The value of an object is changed only {\em via} the assignment
operator.  Using an object in a computation does not change the
value.  For example, suppose you invoke the square-root operator on \code{x}:
\begin{verbatim}
> sqrt(x)
 [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 
\end{verbatim}
The square roots have been returned as a value, but this doesn't
change the value of \code{x}:
\begin{verbatim}
> x
 [1]  1  2  3  4  5  6  7  
\end{verbatim}
If you want to change the value of \code{x}, you need to use the
assignment operator:
\begin{verbatim}
> x = sqrt(x)
> x
 [1] 1.00 1.41 1.73 2.00 2.24 2.45 2.65 
\end{verbatim}
An assignment command like \code{x = sqrt(x)} can be confusing to
people who are used to algebraic notation.  In algebra, the equal sign
describes a relationship between the left and right sides.  
So, $x = \sqrt{x}$ tells us about how the quantity $x$ and the
quantity $\sqrt{x}$ are related.  Students are usually trained to
``solve'' such relationships, going through a series of algebraic 
steps to find values for $x$ that are
consistent with the mathematical statement.  (For $x = \sqrt{x}$, the solutions
are $x=0$ and $x=1$.)  In contrast, the assignment command 
\code{x = sqrt(x)} is a way of replacing the previous values stored
in \code{x} with new values that are the square root of the old
ones.  



\sectiontwo{Connecting Computations}

The brilliant thing about organizing operators in terms of input
arguments and output values is that the output of one operator can be
used as an input to another.  This lets complicated computations be
built out of simpler ones.

For example, suppose you have a list of 10000
voters in a precinct and you want to select a random sample of 20 of
them for a survey. The \code{seq} operator can be used to generate
a set of 10000 choices.  The \code{sample} operator can be used to
select some of these choices at random.


One way to connect the computations is by using objects to store the
intermediate outputs.   
\begin{verbatim}
> choices = seq(1,10000)
> sample( choices, 20 )
 [1] 5970 8476 9340 8266 6909
 [6] 3692 8979 1640 4266 5580
[11] 1208 6141 4973 5575 8498
[16] 1001  923 3246 4194 2126
\end{verbatim}

You can also pass the output of an operator {\em directly} as an
argument to another operator.  Here's another way to accomplish
exactly the same thing as the above.
\begin{verbatim}
> sample( seq(1,10000), 20 )
\end{verbatim}


\sectiontwo{Numbers and Arithmetic}

The language has a concise notation for arithmetic that looks very
much like the traditional one:
\begin{verbatim}
> 7+2
[1] 9
> 3*4
[1] 12
> 5/2
[1] 2.5
> 3-8
[1] -5
> -3
[1] -3
\end{verbatim}
Arithmetic operators, like any other operators, can be connected to
form more complicated computations.  For instance, 
\begin{verbatim}
> 8+4/2
[1] 10
\end{verbatim}
To a human reader, the command \code{8+4/2} might seem ambiguous.
Is it intended to be \code{(8+4)/2} or \code{8+(4/2)}?  The
computer uses unambiguous rules to interpret the expression, but it's
a good idea for you to use parethesis so that you can make sure that
what you intend is what the computer carries out:
\begin{verbatim}
> (8+4)/2
[1] 6
\end{verbatim}

Traditional mathematical notation uses superscripts and radicals to
indicate exponentials and roots, e.g., $3^2$ or $\sqrt{3}$ or
$\sqrt[3]{8}$.  This special typography doesn't work well with an
ordinary keyboard, so R and most other computer 
languages uses a different notation:
\begin{verbatim}
> 3^2
[1] 9
> sqrt(3)
[1] 1.73
> 8^(1/3)
[1] 2
\end{verbatim}

There is a large set of mathematical functions: exponentials, logs,
trigonometric and inverse trigonometric functions:  Some examples:

\bigskip
\centerline{\begin{tabular}{ll}
Traditional & Computer\\\hline
$e^2$ & \code{exp(2)}\\
$\log_e(100)$ & \code{log(100)}\\
$\log_{10}(100)$ &  \code{log10(100)}\\
$\log_{2}(100)$ & \code{log2(100)}\\
$\cos( \frac{\pi}{2}) $ & \code{cos(pi/2)}\\
$\sin( \frac{\pi}{2}) $ & \code{sin(pi/2)}\\
$\tan( \frac{\pi}{2}) $ & \code{tan(pi/2)}\\
$\cos^{-1}(-1)$ & \code{acos(-1)}\\
\end{tabular}}
\bigskip

Numbers can be written in scientific notation.  For example, the
``universal gravitational constant'' that describes the gravitational
attraction between masses is $6.67428 \times 10^{-11}$ (with units
meters-cubed per kilogram per second squared).  In the computer
notation, this would be written \code{G=6.67428e-11}. The Avogradro
number, which gives the number of atoms in a mole, is $6.02214179
\times 10^{23}$ per mole, or \code{6.02214178e23}.

The computer language does not directly support the recording of
units.  This is unfortunate, since in the real world numbers often have
units and the units matter.  For example, in 1999 the Mars Climate
Orbiter crashed into Mars because the design engineers specified the
engine's thrust in units of pounds, while the guidance engineers
thought the units were newtons.

Computer arithmetic is accurate and reliable, but it often
involves very slight rounding of numbers.  Ordinarily, this is not
noticeable.  However, it can become apparent in 
some calculations that produce results that are zero.  For example,
mathematically $\sin(\pi) = 0$, however the computer does not
duplicate this mathematical relationship exactly:
\begin{verbatim}
> sin(pi)
[1] 1.22e-16
\end{verbatim}
Whether a number like this is properly interpreted as ``close to
zero,'' depends on the context and, for quantities that have units, on
the units themselves.  For instance, the unit ``parsec'' is used in
astronomy in reporting distances between stars.  The closest star to
the sun is Proxima, at a distance of 1.3 parsecs. 
A distance of $1.22 \times 10^{-16}$ parsecs is tiny in
astronomy but translates to about 2.5 meters --- not so small on the
human scale.  

In statistics, many calculations relate to probabilities which are
always in the range 0 to 1.  On this scale, \code{1.22e-16} is very
close to zero. 


There are two ``special'' numbers.  \code{Inf} stands for $\infty$, as in 
\begin{verbatim}
> 1/0
[1] Inf
\end{verbatim}
\code{NaN} stands for ``not a number,'' and is the result when a numerical
operation isn't defined, for instance
\begin{verbatim}
> 0/0
[1] NaN
> sqrt(-9)
[1] NaN
\end{verbatim}





\sectiontwo{Types of Objects}

Most of the examples used so far have dealt with numbers.  But
computers work with other kinds of information as well: text,
photographs, sounds, sets of data, and so on.  The word
\newword{type} is used to refer to the kind of information.  

Modern
computer languages support a great variety of types.  There are four
types that will be most important here:
\begin{description}
\item[numeric] The numbers of the sort already encountered.
\item[character] Text data.
\item[logical] Answers to yes/no questions.
\item[data frames] Collections of data more or less in the form of a
  spreadsheet table.  
\end{description}

The reason it's important to know about the types of data is that
operators expect their input arguments to be of specific types.  When
you use the wrong type of input, the computer might not be able process your
command.

\sectiontwo{Character Data}

You indicate character data to the computer by enclosing the text in
double quotation marks.  For example:
\begin{verbatim}
> filename = "swimmers.csv"
\end{verbatim}
There is something a bit subtle going on in the above command, so
look at it carefully.  The purpose of the command is to create an
object, named \code{filename}, that stores a little bit of text data.
Notice that the name of the object is not put in quotes, but the text
data is.  

Whenever you refer to an object name, make sure that you don't use
quotes, for example:
\begin{verbatim}
> filename
[1] "swimmers.csv"
\end{verbatim}
If you make a command with the object name in quotes, it won't be
treated as referring to an object.  Instead, it will merely mean the
text itself:
\begin{verbatim}
> "filename"
[1] "filename"
\end{verbatim}
Similarly, if you omit the quotation marks from around text, the
computer will treat it as if it were an object name and will look for
the object of that name.  For instance, the following command
directs the computer to look up the value contained in an object named
\code{swimmers.csv} and insert that value into the object \code{filename}. 
\begin{verbatim}
> filename = swimmers.csv
Error: object "swimmers.csv" not found
\end{verbatim}
As it happens, there was no object named \code{swimmers.csv} because
it had not been defined by any previous assignment command.  So, the
computer generated an error.

For the most part, you will not need to use very many operators on
text data; you just need to remember to include text, such as file
names, in quotation marks.  Sometimes, you will want to convert
non-text items to text in order to display them in graphs.  There is a
special operator, \code{as.character} for doing this:
\begin{verbatim}
> as.character(3)
[1] "3"
\end{verbatim}
The quotes in the output show that it is character type rather then
numeric type.  This isn't terribly important to the human reader, but
the computer regards \code{"3"} as a different thing than \code{3}.
For instance, you can do arithmetic on numbers but not on characters.
\begin{verbatim}
> 3 + 2
[1] 5
> as.character(3) + 2
Error in as.character(3) + 2 :
 non-numeric argument to binary operator
\end{verbatim}

\sectiontwo{Data Frames}

A data frame is a collection of values arranged as a table.  For
example, here is part of a data frame that records an experiment on
the uptake of carbon dioxide by the grass species {\em Echinochloa crus-galli}. 
\begin{verbatim}
Plant        Type  Treatment conc uptake
  Mc1 Mississippi    chilled  350   18.9
  Mc3 Mississippi    chilled  250   17.9
  Mn3 Mississippi nonchilled   95   11.3
  Mn3 Mississippi nonchilled  350   27.9
  Qn1      Quebec nonchilled  500   35.3
  Qc2      Quebec    chilled  500   38.6
  Qc3      Quebec    chilled  175   21.0
  Qn3      Quebec nonchilled  500   42.9
  Qn3      Quebec nonchilled  175   32.4
... and so on for 84 lines altogether
\end{verbatim}
A data frame is a kind of tabular organization of data.  In this
example, it records several variables: the geographic
origin of the plant (Mississippi or Quebec), and whether the plant had
been chilled overnight before the uptake measurement was made, the
ambient atmospheric CO$_2$ level and the uptake of CO$_2$ by the plant.

Each of the components of the data frame could be stored by an object
of character type or of numerical type, for instance, \code{Treatment}
is character and \code{conc} is numerical.  The data frame brings the
various components together in one place, facilitating processing and
analysis of the data.

The information for a data frame is often stored in a spreadsheet
file and read into R for analysis.  Until you learn how to read in
such files, you can use some of the built-in data frames intended for
example purposes.  If you want to follow along the examples with the
CO$_2$ data frame, use this command to create an object named
\code{CO2} that contains the data frame:
\begin{verbatim}
> data(CO2)
\end{verbatim}

Perhaps the most common operation on a data frame is to refer to the
values in a single column. 
This can be done using a special syntax involving the \verb+$+ sign. 
To refer to the \code{conc} column in the
\code{CO2} data frame, you would use the command
\verb+CO2$conc+.  To refer to the \code{Treatment} column, use
\verb+CO2$Treatment+.  
Think of this style of reference as analogous to naming a person with
a first name and a last name: the name of the data frame object comes
first and the variable name second, separated by the \$, something
like Einstein\$Albert. 

Each component is just like an ordinary object and can be used in any way
you would use an object:
\begin{verbatim}
> length(CO2$conc)
[1] 84
> mean(CO2$conc)
[1] 435
> max(CO2$uptake)
[1] 45.5
> table( CO2$Treatment)
nonchilled    chilled 
        42         42 
\end{verbatim}

Technical note (optional): 
There is another data type, called a \newword{list},
that is closely related to the data frame.
Like data frames, lists can store different types of
data in one place.  But a list does not need to be organized into rows
and columns in the same way as a table.  

\sectiontwo{Logical Data and Logical Operators}

Many computations involve selections of subsets of data that meet some
criterion.  For example, in studying the health of newborn babies, you
might want to focus only on those below a certain birthweight or
perhaps those babies whose mother smoked during pregnancy.  The
question of whether the case satisfies the criterion boils down to a
yes-or-no answer.

Logic is the study of valid inference; it is intimately tied up with
the idea of truth versus falsehood.  In computer languages,
\newword{logical data} refers to a type of data that can represent
whether something is true or false.  To illustrate, consider the
simple sequence 1 to 10
\begin{verbatim}
> x = seq(1,7)
\end{verbatim}
Now a simple question about the values in \code{x}: Are any of them
less than $\pi$?  Here's how you can ask that question:
\begin{verbatim}
> x < pi
 [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

A computer command like \code{x < pi} is not the same as an
algebraic statement like $x < \pi$.  The algebraic statement describes
the relationship between $x$ and $\pi$, namely that $x$ is less than
$\pi$.  The computer command asks a question: Is the value of
\code{x} less than the value of \code{pi}?  Asking this question
invokes a computation; the returned value is the answer to the
question, either \code{TRUE} or \code{FALSE}.  

Here are some of the operators for asking such questions:

\bigskip
\centerline{\begin{tabular}{ll}
\code{x < y} & Is \code{x} less than \code{y}?\\
\code{x <= y} & Is \code{x} less than or equal to \code{y}?\\
\code{x > y} & Is \code{x} greater than \code{y}?\\
\code{x >= y} & Is \code{x} greater than  or equal to \code{y}?\\
\code{x == y} & Is \code{x} equal to \code{y}?\\
\code{x != y} & Is \code{x} unequal to \code{y}?\\
\end{tabular}}
\bigskip
Notice the double equal signs in \code{x == y}.  A single equal sign
would be the assignment operator.

Mostly, these comparison operators apply to numbers.  The \code{==}
and \code{!=} operators also apply to character strings.  To
illustrate, I'll define two objects \code{v} and \code{w}:
\begin{verbatim}
> v = "hello"
> w = seq(1,15,by=3)
> w
 1  4  7 10 13
> w < 12
[1]  TRUE  TRUE  TRUE  TRUE FALSE
> w > 7
[1] FALSE FALSE FALSE  TRUE  TRUE
> w != 4
[1]  TRUE FALSE  TRUE  TRUE  TRUE
> v == "goodbye"
[1] FALSE
> v != "hi"
[1] TRUE
> v == "hello"
[1] TRUE
> v == "Hello"
[1] FALSE
\end{verbatim}
The result \code{FALSE} in the last example stems from the fact that
character strings are compared in a way that takes into account the
difference between upper-case and lower-case letters.

Sometimes you need to combine more than one logical result.  For
example, to ask, ``Is \code{w} between 7 and 12?'' involves combining
two separate questions: ``Is \code{w} greater than 7 AND
is it less than 12?''  In the computer language, this question would
be stated \code{w > 7 & w < 12}. 
\begin{verbatim}
> w > 7 & w < 12
[1] FALSE FALSE FALSE  TRUE FALSE
\end{verbatim}
There are also logical operators for ``or'' and ``not''.  For
instance, you might ask whether \code{w} is less than 5 OR greater
then 9:
\begin{verbatim}
> w < 5 | w > 9
[1]  TRUE  TRUE FALSE  TRUE  TRUE
\end{verbatim}
The ``not'' operator just flips \code{TRUE} and \code{FALSE}:
\begin{verbatim}
> !(w < 5 | w > 9)
[1] FALSE FALSE  TRUE FALSE FALSE
\end{verbatim}
As this example illustrates, you can group logical operations in just
the same way as arithmetic operations. 




\sectiontwo{Missing Data}

When recording data from an experiment or an observational study, it
sometimes happens that a particular measurement can't be made or is
lost or is otherwise unavailable.  In R, such \newword{missing data}
can be recorded with the special code \code{NA}.  As you might expect,
arithmetic and other operations on missing data can't be sensibly
performed: giving NA as an input produces NA as an output.
\begin{verbatim}
> 7 == NA
[1] NA
> NA == 'Hello'
[1] NA
> NA == NA
[1] NA
\end{verbatim}
In order to test whether there is missing data, a special operator
\code{is.na} can be used:
\begin{verbatim}
> is.na(NA)
[1] TRUE
\end{verbatim}


\sectiontwo{Collections}

R can work with collections of numbers and
character strings.  Some operators work on each item in the
collection, while others combine the items together in some way.  To
illustrate, I'll define three small collections, \code{x}, \code{y},
and \code{fruits}:
\begin{verbatim}
> x = seq(1,10)
> x
 [1]  1  2  3  4  5  6  7  

> y = c(7,8,9)
> y
[1] 7 8 9

> fruits = c("apple","berry","cherry")
> fruits
[1] "apple"  "berry"  "cherry"
\end{verbatim}
The \code{c} operator used in defining \code{y} and \code{fruits} is
useful for creating a small collection ``by hand.''  Often, however,
collections will be created by reading in data from a file or using
some other operator.  I'll introduce these as needed for specific tasks.

Arithmetic and comparison operators often work item-by-item on the
collection.  For example:
\begin{verbatim}
> x + 100
 [1] 101 102 103 104 105 106 107 
> sqrt(y)
[1] 2.645751 2.828427 3.000000
> fruits == 'cherry'
[1] FALSE FALSE  TRUE
\end{verbatim}
If the operator involves two collections, they have to be the same
size, or R will reuse the smaller collection to match the size of the
larger one:
\begin{verbatim}
> x == y
 [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE 
Warning message:
In x == y : longer object length is not a 
            multiple of shorter object length
\end{verbatim}
The warning message is displayed when some aspect of the computation
is deemed suspect or odd.  Pay attention to such messages since they
may signal that the computation the interpreter carried out is not the
one you intended.  

It's usually obvious what sorts of operators will combine the items
of the collection rather than working on them item by item.  Here are
some examples:
\begin{verbatim}
> mean(x)
[1] 4
> median(y)
[1] 8
> min(x)
[1] 1
> max(x)
[1] 7
> sum(x)
[1] 28
> any( fruits == 'cherry')
[1] TRUE
> all( fruits == 'cherry')
[1] FALSE
\end{verbatim}

The \code{length} operator tells how many items there are in the
collection:
\begin{verbatim}
> length(x)
[1] 10
> length(y)
[1] 3
> length(fruits)
[1] 3
\end{verbatim}

When there are too many items in a collection to display conveniently
in one line, the R interpreter will break up the display over multiple
lines.  
\begin{verbatim}
> seq(3,19)
 [1]  3  4  5  6  7  8  9 10 11
[10] 12 13 14 15 16 17 18 19
\end{verbatim}
At the start of each line, the number in brackets tells the
index of the item that starts that line.  In the above, for instance,
the item 3 is displayed following a \code{[1]} because 3 is the first
item in the collection.  Similarly, the \code{[10]} indicates that the
item 12 is the tenth item in the collection.  The brackets are just
for display purposes; they are not part of the collection itself.

\sectiontwo{Defining your own operators}

Occasionally, you may need to define your own operators.  This is
convenient if you need to repeat an operation many times or if you
need to define a mathematical function.

It's important to keep in mind the difference between an operator and
a command.  A command is an instruction to perform a particular
computation on a particular input argument or set of input arguments.
The input arguments always have to be values, though of course you can
refer to the value by giving the name of an object that has already
been assigned a value.

In contrast, in defining an operator, you can treat the arguments
abstractly; just a name without a value having been assigned.  To
illustrate, here is a command that creates the mathematical
function $f(x) = 3 x^2 + 2$ and stores it in an operator named \code{f}:
\begin{verbatim}
> f = function(x) { 3*x^2 + 2 }
\end{verbatim}
One you have defined the function, you can invoke it in the standard
way.  For example:
\begin{verbatim}
> f(3)
[1] 29
> f(10)
[1] 302
\end{verbatim}

There are some novel features to the syntax used to define a new
operator.  First, the arguments to \code{function} aren't treated as
values but as pure names.  Second, the contents of the 
curly braces \verb+{+ and \verb+}+ --- I'll call these the
\newword{function contents} --- are the commands that will be 
evaluated when the function is invoked.

It doesn't matter what names you use in the function contents so long
as they match the names used in the arguments to \code{function}.  For
example, here is another operator, called \code{g}, that will perform
exactly the same computation as \code{f} when invoked:
\begin{verbatim}
> g = function(marge) { 3*marge^2 + 2 }
\end{verbatim}

When you invoke an operator, the interpreter carries out several
steps.  Consider the invocation
\begin{verbatim}
> g(7)
\end{verbatim}
In carrying out this command, the interpreter will:
\begin{enumerate}
\item Temporarily define or redefine an object \code{marge} that has
  the value 7.
\item Execute the function contents.
\item Return the value of these contents as the return value of the
  command.
\item Discard the definition or redefinition in (1).
\end{enumerate}

Operators can have more than one argument.  For instance, here is an
operator \code{hypotenuse} that computes the length of the hypotenuse
of a right triangle given the lengths of the legs
\begin{verbatim}
> hypotenuse = function(a,b) { sqrt( a^2 + b^2 ) }
\end{verbatim}


When programmers create new operators that they expect to use on many
different occasions, they put the commands
to define the operators into a text file called a 
\newword{source file}.  
This file can be read into R using a special operator, called
\code{source} that causes the commands to be executed, thereby
defining the new operators.


\sectiontwo{Saving and Documenting Your Work}

Up to now, the commands used as examples have been simple one-line
statements.  As you work further, you will build more elaborate
computations by combining simpler ones.  It will become important to
be able to document what you have done, providing a record so that
others can confirm your results and so that you and others can modify
your work as needed.

One way in which a record is created of your interaction with the
computer is the dialog in the interpreter console itself.  In some
ways this is analogous to a document created by a word processor: for
example, you can copy the contents and paste it into another document.

But the idea of dialog-as-document is flawed.  For example, in a
word-processor, when you correct a mistake the old version is erased.
But in the R dialog, to fix a mistake you give a new command --- the
old, mistaken command is still there in the dialog.


You should keep in mind that there are several different components,
some of which are more appropriate than others for your documentation.

\begin{description}
\item[Your Commands]  The commands that you execute are what defines
  the computation being performed.  These commands themselves are a
  valuable form of documentation. 

\item[The objects you create] These objects, and the values that are
  stored in them, reflect the \newword{state} of the computation.  If
  you want to pick up on your work where you left off, you can save
  these objects.  This is called ``saving the \newword{workspace}.''

\item[Side effects]  This refers to the output printed by the
  interpreter and plots.  Sometimes you will want to include this in your
  documentation, but usually just select elements.
\end{description}

\sectionone{Using Customizations to R}

One of the features that makes R so powerful is that new commands can easily be
added to the system.  This makes it possible, for instance, to
customize the software to make routine tasks easier.  Such
customizations have been written specifically for the people following
this book.  To use them --- and you will need them in later chapters
--- you should [[[[[[ instructions for reading in the customization files]]]]]


